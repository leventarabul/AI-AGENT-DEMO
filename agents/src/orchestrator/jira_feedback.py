"""Jira feedback module for execution trace reporting.

Posts human-readable pipeline execution results back to Jira issues
to close the SDLC feedback loop.

Key principles:
- Single source of truth: ExecutionTrace
- One-way communication: Read event, write feedback
- Orchestrator-controlled: No agent-to-Jira direct calls
- Clear human-readable format
"""

from typing import Optional
from orchestrator.execution_trace import ExecutionTrace, PipelineStatus, StepStatus
from clients.jira_client import JiraClient


class JiraFeedbackService:
    """Service for posting execution trace results to Jira."""
    
    def __init__(self, jira_client: JiraClient):
        """Initialize the feedback service.
        
        Args:
            jira_client: Jira client for API calls
        """
        self.jira_client = jira_client
    
    async def post_feedback(
        self,
        trace: ExecutionTrace,
        update_status: bool = True,
    ) -> None:
        """Post execution trace feedback to Jira.
        
        Creates a human-readable comment summarizing the pipeline execution
        and optionally updates the issue status based on the result.
        
        Args:
            trace: The execution trace to report
            update_status: Whether to update Jira issue status
        """
        # Only post feedback if we have a Jira issue key
        if not trace.trigger.issue_key:
            return
        
        issue_key = trace.trigger.issue_key
        
        # Generate human-readable comment
        comment = self._format_trace_comment(trace)
        
        # Post comment to Jira
        await self.jira_client.add_comment(issue_key, comment)
        
        # Optionally update issue status
        if update_status:
            await self._update_issue_status(issue_key, trace)
    
    def _format_trace_comment(self, trace: ExecutionTrace) -> str:
        """Format execution trace as human-readable Jira comment.
        
        Args:
            trace: The execution trace
            
        Returns:
            Formatted comment text
        """
        # Header with overall status
        status_emoji = {
            PipelineStatus.SUCCESS: "âœ…",
            PipelineStatus.PARTIAL: "âš ï¸",
            PipelineStatus.FAILED: "âŒ",
            PipelineStatus.RUNNING: "â³",
        }.get(trace.pipeline_status, "â“")
        
        lines = [
            f"{status_emoji} **Pipeline Execution Report**",
            "",
            f"**Trace ID:** {trace.trace_id}",
            f"**Intent:** {trace.intent_type}",
            f"**Status:** {trace.pipeline_status.value}",
        ]
        
        # Execution plan summary
        if trace.execution_plan_summary:
            lines.extend([
                "",
                f"**Execution Plan:** {trace.execution_plan_summary}",
            ])
        
        # Step-by-step results
        lines.extend([
            "",
            f"**Steps Executed:** ({len(trace.steps)} total)",
        ])
        
        for step in trace.steps:
            step_emoji = {
                StepStatus.SUCCESS: "âœ…",
                StepStatus.FAIL: "âŒ",
                StepStatus.BLOCKED: "ðŸš«",
                StepStatus.STARTED: "â³",
            }.get(step.status, "â“")
            
            lines.append(f"{step.step_number}. {step_emoji} **{step.agent_name}**: {step.status.value}")
            lines.append(f"   - Task: {step.agent_task}")
            
            if step.output_summary:
                lines.append(f"   - Result: {step.output_summary}")
            
            if step.error_message:
                lines.append(f"   - Error: {step.error_message}")
        
        # Final error if any
        if trace.final_error:
            lines.extend([
                "",
                f"**Error:** {trace.final_error}",
            ])
        
        # Timing information
        if trace.completed_at:
            lines.extend([
                "",
                f"**Started:** {trace.started_at}",
                f"**Completed:** {trace.completed_at}",
            ])
        
        # Footer
        lines.extend([
            "",
            "---",
            "_This report was automatically generated by the AI Agent Orchestrator._",
        ])
        
        return "\n".join(lines)
    
    async def _update_issue_status(
        self,
        issue_key: str,
        trace: ExecutionTrace,
    ) -> None:
        """Update Jira issue status based on pipeline result.
        
        Status mapping:
        - SUCCESS â†’ "Done"
        - PARTIAL/FAIL â†’ "Blocked" or "In Review"
        - RUNNING â†’ No change (shouldn't happen)
        
        Args:
            issue_key: The Jira issue key
            trace: The execution trace
        """
        # Get available transitions for this issue
        transitions = await self.jira_client.get_transitions(issue_key)
        
        # Map pipeline status to desired Jira status
        target_status = None
        
        if trace.pipeline_status == PipelineStatus.SUCCESS:
            target_status = "Done"
        elif trace.pipeline_status in [PipelineStatus.PARTIAL, PipelineStatus.FAILED]:
            # Try "Blocked" first, fall back to "In Review"
            target_status = "Blocked"
        
        if not target_status:
            return
        
        # Find matching transition
        transition_id = None
        for transition in transitions:
            if transition.get("name", "").lower() == target_status.lower():
                transition_id = transition.get("id")
                break
        
        # If "Blocked" not found and we wanted it, try "In Review"
        if not transition_id and target_status == "Blocked":
            for transition in transitions:
                if transition.get("name", "").lower() == "in review":
                    transition_id = transition.get("id")
                    break
        
        # Perform transition if found
        if transition_id:
            await self.jira_client.transition_issue(
                issue_key,
                transition_id,
            )


def create_jira_feedback_service(
    jira_url: str,
    username: str,
    api_token: str,
) -> JiraFeedbackService:
    """Factory function to create JiraFeedbackService.
    
    Args:
        jira_url: Jira base URL
        username: Jira username/email
        api_token: Jira API token
        
    Returns:
        Configured JiraFeedbackService instance
    """
    jira_client = JiraClient(
        jira_url=jira_url,
        username=username,
        api_token=api_token,
    )
    return JiraFeedbackService(jira_client)


async def post_trace_to_jira(
    trace_id: str,
    jira_url: str,
    username: str,
    api_token: str,
    update_status: bool = True,
) -> None:
    """Post execution trace feedback to Jira.
    
    Convenience function that retrieves trace from store and posts to Jira.
    
    Args:
        trace_id: The trace ID to post
        jira_url: Jira base URL
        username: Jira username/email
        api_token: Jira API token
        update_status: Whether to update Jira issue status
    """
    from orchestrator.execution_trace import get_trace_store
    
    # Get trace from store
    trace_store = get_trace_store()
    trace = trace_store.get(trace_id)
    
    if not trace:
        # No trace found - nothing to post
        return
    
    # Create feedback service and post
    service = create_jira_feedback_service(jira_url, username, api_token)
    await service.post_feedback(trace, update_status)
